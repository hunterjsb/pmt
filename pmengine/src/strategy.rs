//! Strategy trait and runtime for trading strategies.

use crate::orderbook::OrderBook;
use crate::position::{Fill, PositionTracker};
use chrono::{DateTime, Utc};
use rust_decimal::Decimal;
use std::collections::HashMap;
use std::sync::Arc;

/// Urgency level for order execution.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Urgency {
    /// Post-only limit order, willing to wait
    Low,
    /// Standard limit order
    Medium,
    /// Aggressive limit order, cross spread if needed
    High,
    /// Immediate execution, use market order
    Immediate,
}

impl Default for Urgency {
    fn default() -> Self {
        Urgency::Medium
    }
}

/// Trading signal generated by a strategy.
#[derive(Debug, Clone)]
pub enum Signal {
    /// Buy signal
    Buy {
        token_id: String,
        price: Decimal,
        size: Decimal,
        urgency: Urgency,
    },
    /// Sell signal
    Sell {
        token_id: String,
        price: Decimal,
        size: Decimal,
        urgency: Urgency,
    },
    /// Cancel existing orders for a token
    Cancel { token_id: String },
    /// No action
    Hold,
    /// Request graceful shutdown with a reason
    Shutdown { reason: String },
}

/// Market metadata from Gamma API.
///
/// This provides information about the market that a token belongs to,
/// including the question, outcome name, and expiration time.
#[derive(Debug, Clone)]
pub struct MarketInfo {
    /// The market question (e.g., "Will X happen?")
    pub question: String,
    /// Which outcome this token represents (e.g., "Yes" or "No")
    pub outcome: String,
    /// URL slug for the market
    pub slug: String,
    /// When the market expires/resolves
    pub end_date: Option<DateTime<Utc>>,
    /// Hours until expiry (computed at context creation time)
    pub hours_until_expiry: Option<f64>,
    /// Total liquidity in USDC (from Gamma API)
    pub liquidity: Option<f64>,
}

impl MarketInfo {
    /// Create a new MarketInfo.
    pub fn new(
        question: String,
        outcome: String,
        slug: String,
        end_date: Option<DateTime<Utc>>,
    ) -> Self {
        Self::with_liquidity(question, outcome, slug, end_date, None)
    }

    /// Create a new MarketInfo with liquidity data.
    pub fn with_liquidity(
        question: String,
        outcome: String,
        slug: String,
        end_date: Option<DateTime<Utc>>,
        liquidity: Option<f64>,
    ) -> Self {
        let hours_until_expiry = end_date.map(|end| {
            let now = Utc::now();
            let duration = end.signed_duration_since(now);
            duration.num_seconds() as f64 / 3600.0
        });

        Self {
            question,
            outcome,
            slug,
            end_date,
            hours_until_expiry,
            liquidity,
        }
    }
}

/// Context provided to strategies for decision making.
#[derive(Debug, Clone)]
pub struct StrategyContext {
    /// Current timestamp
    pub timestamp: DateTime<Utc>,
    /// Order books by token ID (full depth)
    pub order_books: HashMap<String, Arc<OrderBook>>,
    /// Current positions
    pub positions: PositionTracker,
    /// Market metadata by token ID (from Gamma API)
    pub markets: HashMap<String, MarketInfo>,
    /// Total unrealized P&L
    pub unrealized_pnl: Decimal,
    /// Total realized P&L
    pub realized_pnl: Decimal,
    /// Available USDC balance for trading
    pub usdc_balance: Decimal,
}


/// Trait for implementing trading strategies.
pub trait Strategy: Send + Sync {
    /// Unique identifier for this strategy.
    fn id(&self) -> &str;

    /// Token IDs this strategy wants to subscribe to.
    fn subscriptions(&self) -> Vec<String>;

    /// Called on each tick with current market state.
    /// Returns signals for order management.
    fn on_tick(&mut self, ctx: &StrategyContext) -> Vec<Signal>;

    /// Called when an order is filled.
    fn on_fill(&mut self, _fill: &Fill) {}

    /// Called on shutdown for cleanup.
    fn on_shutdown(&mut self) {}
}

/// Runtime for executing multiple strategies.
pub struct StrategyRuntime {
    strategies: Vec<Box<dyn Strategy>>,
}

impl StrategyRuntime {
    pub fn new() -> Self {
        Self {
            strategies: Vec::new(),
        }
    }

    /// Register a strategy.
    pub fn register(&mut self, strategy: Box<dyn Strategy>) {
        tracing::info!(strategy_id = strategy.id(), "Registering strategy");
        self.strategies.push(strategy);
    }

    /// Get all token subscriptions from all strategies.
    pub fn all_subscriptions(&self) -> Vec<String> {
        let mut subs: Vec<String> = self
            .strategies
            .iter()
            .flat_map(|s| s.subscriptions())
            .collect();
        subs.sort();
        subs.dedup();
        subs
    }

    /// Run all strategies and collect signals.
    pub fn tick(&mut self, ctx: &StrategyContext) -> Vec<Signal> {
        let mut all_signals = Vec::new();
        for strategy in &mut self.strategies {
            let signals = strategy.on_tick(ctx);
            for signal in signals {
                tracing::debug!(strategy_id = strategy.id(), ?signal, "Strategy signal");
                all_signals.push(signal);
            }
        }
        all_signals
    }

    /// Notify all strategies of a fill.
    pub fn on_fill(&mut self, fill: &Fill) {
        for strategy in &mut self.strategies {
            strategy.on_fill(fill);
        }
    }

    /// Shutdown all strategies.
    pub fn shutdown(&mut self) {
        for strategy in &mut self.strategies {
            tracing::info!(strategy_id = strategy.id(), "Shutting down strategy");
            strategy.on_shutdown();
        }
    }
}

impl Default for StrategyRuntime {
    fn default() -> Self {
        Self::new()
    }
}

/// Example: Simple market maker strategy (for testing).
pub struct DummyStrategy {
    id: String,
    tokens: Vec<String>,
}

impl DummyStrategy {
    pub fn new(id: &str, tokens: Vec<String>) -> Self {
        Self {
            id: id.to_string(),
            tokens,
        }
    }
}

impl Strategy for DummyStrategy {
    fn id(&self) -> &str {
        &self.id
    }

    fn subscriptions(&self) -> Vec<String> {
        self.tokens.clone()
    }

    fn on_tick(&mut self, ctx: &StrategyContext) -> Vec<Signal> {
        // Just log market state, don't trade
        for token_id in &self.tokens {
            if let Some(book) = ctx.order_books.get(token_id) {
                tracing::debug!(
                    token_id,
                    best_bid = ?book.best_bid().map(|l| l.price),
                    best_ask = ?book.best_ask().map(|l| l.price),
                    mid = ?book.mid_price(),
                    bid_levels = book.bids.len(),
                    ask_levels = book.asks.len(),
                    "Market state"
                );
            }
        }
        vec![Signal::Hold]
    }
}
