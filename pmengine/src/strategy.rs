//! Strategy trait and runtime for trading strategies.

use crate::position::{Fill, PositionTracker};
use rust_decimal::Decimal;
use std::collections::HashMap;

/// Urgency level for order execution.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Urgency {
    /// Post-only limit order, willing to wait
    Low,
    /// Standard limit order
    Medium,
    /// Aggressive limit order, cross spread if needed
    High,
    /// Immediate execution, use market order
    Immediate,
}

impl Default for Urgency {
    fn default() -> Self {
        Urgency::Medium
    }
}

/// Trading signal generated by a strategy.
#[derive(Debug, Clone)]
pub enum Signal {
    /// Buy signal
    Buy {
        token_id: String,
        price: Decimal,
        size: Decimal,
        urgency: Urgency,
    },
    /// Sell signal
    Sell {
        token_id: String,
        price: Decimal,
        size: Decimal,
        urgency: Urgency,
    },
    /// Cancel existing orders for a token
    Cancel { token_id: String },
    /// No action
    Hold,
}

/// Context provided to strategies for decision making.
#[derive(Debug)]
pub struct StrategyContext {
    /// Current timestamp
    pub timestamp: chrono::DateTime<chrono::Utc>,
    /// Order books by token ID (best bid, best ask, bid_size, ask_size)
    pub order_books: HashMap<String, OrderBookSnapshot>,
    /// Current positions
    pub positions: PositionTracker,
    /// Total unrealized P&L
    pub unrealized_pnl: Decimal,
    /// Total realized P&L
    pub realized_pnl: Decimal,
}

/// Snapshot of order book top-of-book.
#[derive(Debug, Clone, Default)]
pub struct OrderBookSnapshot {
    pub token_id: String,
    pub best_bid: Option<Decimal>,
    pub best_ask: Option<Decimal>,
    pub bid_size: Decimal,
    pub ask_size: Decimal,
    pub mid_price: Option<Decimal>,
    pub spread: Option<Decimal>,
    pub last_update: chrono::DateTime<chrono::Utc>,
}

impl OrderBookSnapshot {
    pub fn new(token_id: String) -> Self {
        Self {
            token_id,
            best_bid: None,
            best_ask: None,
            bid_size: Decimal::ZERO,
            ask_size: Decimal::ZERO,
            mid_price: None,
            spread: None,
            last_update: chrono::Utc::now(),
        }
    }

    pub fn update(&mut self, best_bid: Option<Decimal>, best_ask: Option<Decimal>, bid_size: Decimal, ask_size: Decimal) {
        self.best_bid = best_bid;
        self.best_ask = best_ask;
        self.bid_size = bid_size;
        self.ask_size = ask_size;
        self.last_update = chrono::Utc::now();

        // Calculate derived fields
        self.mid_price = match (best_bid, best_ask) {
            (Some(bid), Some(ask)) => Some((bid + ask) / Decimal::TWO),
            _ => None,
        };
        self.spread = match (best_bid, best_ask) {
            (Some(bid), Some(ask)) => Some(ask - bid),
            _ => None,
        };
    }
}

/// Trait for implementing trading strategies.
pub trait Strategy: Send + Sync {
    /// Unique identifier for this strategy.
    fn id(&self) -> &str;

    /// Token IDs this strategy wants to subscribe to.
    fn subscriptions(&self) -> Vec<String>;

    /// Called on each tick with current market state.
    /// Returns signals for order management.
    fn on_tick(&mut self, ctx: &StrategyContext) -> Vec<Signal>;

    /// Called when an order is filled.
    fn on_fill(&mut self, _fill: &Fill) {}

    /// Called on shutdown for cleanup.
    fn on_shutdown(&mut self) {}
}

/// Runtime for executing multiple strategies.
pub struct StrategyRuntime {
    strategies: Vec<Box<dyn Strategy>>,
}

impl StrategyRuntime {
    pub fn new() -> Self {
        Self {
            strategies: Vec::new(),
        }
    }

    /// Register a strategy.
    pub fn register(&mut self, strategy: Box<dyn Strategy>) {
        tracing::info!(strategy_id = strategy.id(), "Registering strategy");
        self.strategies.push(strategy);
    }

    /// Get all token subscriptions from all strategies.
    pub fn all_subscriptions(&self) -> Vec<String> {
        let mut subs: Vec<String> = self
            .strategies
            .iter()
            .flat_map(|s| s.subscriptions())
            .collect();
        subs.sort();
        subs.dedup();
        subs
    }

    /// Run all strategies and collect signals.
    pub fn tick(&mut self, ctx: &StrategyContext) -> Vec<Signal> {
        let mut all_signals = Vec::new();
        for strategy in &mut self.strategies {
            let signals = strategy.on_tick(ctx);
            for signal in signals {
                tracing::debug!(strategy_id = strategy.id(), ?signal, "Strategy signal");
                all_signals.push(signal);
            }
        }
        all_signals
    }

    /// Notify all strategies of a fill.
    pub fn on_fill(&mut self, fill: &Fill) {
        for strategy in &mut self.strategies {
            strategy.on_fill(fill);
        }
    }

    /// Shutdown all strategies.
    pub fn shutdown(&mut self) {
        for strategy in &mut self.strategies {
            tracing::info!(strategy_id = strategy.id(), "Shutting down strategy");
            strategy.on_shutdown();
        }
    }
}

impl Default for StrategyRuntime {
    fn default() -> Self {
        Self::new()
    }
}

/// Example: Simple market maker strategy (for testing).
pub struct DummyStrategy {
    id: String,
    tokens: Vec<String>,
}

impl DummyStrategy {
    pub fn new(id: &str, tokens: Vec<String>) -> Self {
        Self {
            id: id.to_string(),
            tokens,
        }
    }
}

impl Strategy for DummyStrategy {
    fn id(&self) -> &str {
        &self.id
    }

    fn subscriptions(&self) -> Vec<String> {
        self.tokens.clone()
    }

    fn on_tick(&mut self, ctx: &StrategyContext) -> Vec<Signal> {
        // Just log market state, don't trade
        for token_id in &self.tokens {
            if let Some(book) = ctx.order_books.get(token_id) {
                tracing::debug!(
                    token_id,
                    best_bid = ?book.best_bid,
                    best_ask = ?book.best_ask,
                    mid = ?book.mid_price,
                    "Market state"
                );
            }
        }
        vec![Signal::Hold]
    }
}
